<!DOCTYPE html>
<html lang="hi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Bubble Shooter - Fade & BGM</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      display: flex;
      align-items: center;
      justify-content: center;
      background: #000;
      height: 100vh;
      overflow: hidden;
      font-family: Arial, sans-serif;
      color: #fff;
    }
    #container {
      position: relative;
      width: min(480px, 94vw);
      height: min(800px, 90vh);
      overflow: hidden;
      border-radius: 14px;
      box-shadow: 0 0 20px rgba(0,0,0,0.6);
    }
    canvas { width: 100%; height: 100%; display: block; }
    .hud {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.5);
      padding: 6px 12px;
      border-radius: 8px;
      font-weight: bold;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div id="container">
    <canvas id="game"></canvas>
    <div class="hud" id="hud">Score: 0</div>
    <audio id="bgm" src="sounds/bgm.mpeg" loop></audio>
  </div>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const hud = document.getElementById("hud");
    const bgm = document.getElementById("bgm");

    function resize() {
      canvas.width = canvas.clientWidth;
      canvas.height = canvas.clientHeight;
    }
    window.addEventListener("resize", resize);
    resize();

    // Start BGM
    document.body.addEventListener("click", () => {
      bgm.volume = 0.5;
      bgm.play().catch(() => {});
    }, { once: true });

    // Load images
    const bg = new Image();
    bg.src = "images/background.png";

    const bubbles = [];
    for (let i = 1; i <= 7; i++) {
      const img = new Image();
      img.src = `images/bubble${i}.png`;
      bubbles.push(img);
    }

    // Game variables
    const R = 20;
    const cols = 11;
    const rows = 15;
    const grid = [];
    let score = 0;

    // Bubble fade storage
    const fading = [];

    for (let r = 0; r < rows; r++) {
      grid[r] = [];
      for (let c = 0; c < cols; c++) {
        grid[r][c] = r < 5 ? { type: Math.floor(Math.random() * 7), alpha: 1 } : null;
      }
    }

    const shooter = {
      x: canvas.width / 2,
      y: canvas.height - 40,
      angle: -Math.PI / 2,
      next: Math.floor(Math.random() * 7),
    };
    const bullet = { active: false, x: 0, y: 0, dx: 0, dy: 0, type: 0, speed: 8 };

    canvas.addEventListener("mousemove", (e) => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      shooter.angle = Math.atan2(my - shooter.y, mx - shooter.x);
      if (shooter.angle > -0.1) shooter.angle = -0.1;
      if (shooter.angle < -Math.PI + 0.1) shooter.angle = -Math.PI + 0.1;
    });

    canvas.addEventListener("click", shoot);

    function shoot() {
      if (bullet.active) return;
      bullet.active = true;
      bullet.x = shooter.x;
      bullet.y = shooter.y;
      bullet.dx = Math.cos(shooter.angle) * bullet.speed;
      bullet.dy = Math.sin(shooter.angle) * bullet.speed;
      bullet.type = shooter.next;
      shooter.next = Math.floor(Math.random() * 7);
    }

    function findCell(x, y) {
      const c = Math.round((x - 25) / (R * 2));
      const r = Math.round((y - 25) / (R * 2));
      return { r, c };
    }

    function validCell(r, c) {
      return r >= 0 && r < rows && c >= 0 && c < cols;
    }

    function placeBubble(x, y, type) {
      const { r, c } = findCell(x, y);
      if (!validCell(r, c)) return;
      if (!grid[r][c]) grid[r][c] = { type, alpha: 1 };

      const combo = findCluster(r, c);
      if (combo.length >= 3) {
        let pts = 0;
        if (combo.length === 3) pts = 10;
        else if (combo.length === 4) pts = 20;
        else if (combo.length === 5) pts = 30;
        else pts = 40;

        score += pts;
        combo.forEach(({ r, c }) => {
          if (grid[r][c]) {
            fading.push({ r, c, alpha: 1, type: grid[r][c].type });
            grid[r][c] = null;
          }
        });
      }
      hud.textContent = `Score: ${score}`;
    }

    function findCluster(sr, sc) {
      const type = grid[sr][sc]?.type;
      if (type == null) return [];
      const visited = Array.from({ length: rows }, () => Array(cols).fill(false));
      const stack = [{ r: sr, c: sc }];
      const cluster = [];
      const dirs = [
        [1, 0], [-1, 0], [0, 1], [0, -1],
        [1, 1], [-1, -1], [1, -1], [-1, 1]
      ];
      while (stack.length) {
        const { r, c } = stack.pop();
        if (!validCell(r, c) || visited[r][c]) continue;
        visited[r][c] = true;
        if (!grid[r][c] || grid[r][c].type !== type) continue;
        cluster.push({ r, c });
        dirs.forEach(([dr, dc]) => stack.push({ r: r + dr, c: c + dc }));
      }
      return cluster;
    }

    function updateBullet() {
      if (!bullet.active) return;
      bullet.x += bullet.dx;
      bullet.y += bullet.dy;

      if (bullet.x < R || bullet.x > canvas.width - R) bullet.dx *= -1;

      if (bullet.y < R + 10) {
        placeBubble(bullet.x, bullet.y, bullet.type);
        bullet.active = false;
        return;
      }

      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const cell = grid[r][c];
          if (cell) {
            const cx = 25 + c * R * 2;
            const cy = 25 + r * R * 2;
            const dist = Math.hypot(cx - bullet.x, cy - bullet.y);
            if (dist < R * 2 - 2) {
              placeBubble(bullet.x, bullet.y, bullet.type);
              bullet.active = false;
              return;
            }
          }
        }
      }

      if (bullet.y > canvas.height + R) bullet.active = false;
    }

    function updateFading() {
      for (let i = fading.length - 1; i >= 0; i--) {
        fading[i].alpha -= 0.05;
        if (fading[i].alpha <= 0) fading.splice(i, 1);
      }
    }

    function draw() {
      if (bg.complete) ctx.drawImage(bg, 0, 0, canvas.width, canvas.height);
      else {
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }

      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const cell = grid[r][c];
          if (cell) {
            const x = 25 + c * R * 2;
            const y = 25 + r * R * 2;
            const img = bubbles[cell.type];
            if (img.complete) ctx.drawImage(img, x - R, y - R, R * 2, R * 2);
          }
        }
      }

      // Fade animation
      fading.forEach(({ r, c, alpha, type }) => {
        const x = 25 + c * R * 2;
        const y = 25 + r * R * 2;
        ctx.globalAlpha = alpha;
        ctx.drawImage(bubbles[type], x - R, y - R, R * 2, R * 2);
        ctx.globalAlpha = 1;
      });

      const nextImg = bubbles[shooter.next];
      if (nextImg.complete)
        ctx.drawImage(nextImg, shooter.x - R, shooter.y - R, R * 2, R * 2);

      const ex = shooter.x + Math.cos(shooter.angle) * 60;
      const ey = shooter.y + Math.sin(shooter.angle) * 60;
      ctx.strokeStyle = "white";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(shooter.x, shooter.y);
      ctx.lineTo(ex, ey);
      ctx.stroke();

      if (bullet.active) {
        const img = bubbles[bullet.type];
        if (img.complete)
          ctx.drawImage(img, bullet.x - R, bullet.y - R, R * 2, R * 2);
      }
    }

    function loop() {
      updateBullet();
      updateFading();
      draw();
      requestAnimationFrame(loop);
    }

    loop();
  </script>
</body>
</html>